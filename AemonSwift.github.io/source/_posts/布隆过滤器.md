---
title: 布隆过滤器
date: 2019-10-31 19:38:18
tags:
---


# 问题
假设你现在要处理这样一个问题，你有一个网站并且拥有很多访客，每当有用户访问时，你想知道这个ip是不是第一次访问你的网站。这是一个很常见的场景，为了完成这个功能，你很容易就会想到下面这个解决方案：
把访客的ip存进一个hash表中，每当有新的访客到来时，先检查哈希表中是否有改访客的ip，如果有则说明该访客在黑名单中。你还知道，hash表的存取时间复杂度都是O(1),效率很高，因此你对你的方案很是满意。
然后我们假设你的网站已经被1亿个用户访问过，每个ip的长度是15，那么你一共需要$15 * 100000000 = 1500000000Bytes = 1.4G$，这还没考虑hash冲突的问题（hash表中的槽位越多，越浪费空间，槽位越少，效率越低）。
于是聪明的你稍一思考，又想到可以把ip转换成无符号的int型值来存储，这样一个ip只需要占用4个字节就行了，这时1亿个ip占用的空间是$4 * 100000000 = 400000000Bytes = 380M$，空间消耗降低了很多。
那还有没有在不影响存取效率的前提下更加节省空间的办法呢?

# BitSet
32位无符号int型能表示的最大值是4294967295，所有的ip都在这个范围内，我们可以用一个bit位来表示某个ip是否出现过，如果出现过，就把代表该ip的bit位置为1，那么我们最多需要429496729个bit就可以表示所有的ip了。举个例子比如10.0.0.1转换成int是167772161，那么把长度为4294967295的bit数组的第167772161个位置置为1即可，当有ip访问时，只需要检查该标志位是否为1就行了。`4294967295bit = 536870912Byte = 512M`。如果用hash表示所有4294967295范围内的数组的话，需要十几G的空间。
当然，这里举ip的例子不一定合适，主要目的是为了引出BitSet。

## 实现过程
例子：首先，比如我们有一个长度=2的byte数组，2个字节一共有16位，可以表示0-15的数字是否存在。比如我们要验证11是否出现过，那么我们先检查第11个位置是否为1，如果为0，说明11没出现过，然后我们把第11位置为1，表示11已经出现过了。
故BitSet基本只有两个操作，set(int value) 和 isHas(int value)

### set(int value)
我们先来看set怎么实现，因为一个byte占8位，所以对于一个给定的value，我们先求出该value应该位于哪个Byte上，这很简单，int byteIndex = value / 8;
找到value在byte数组中的位置后，再就是在该字节中寻找表示value的bit位，我们知道，一个byte其实就是一个长为8的bit数组，那么value在该bit数组中的位置也就很好算了，int bitIndex = value % 8;
最后我们把该bit位设置为1就可以了：byte[byteIndex] = byte[byteIndex] | 1 << ( 7 - bitIndex)
```c++
void set(int value){
  int byteIndex = value / 8;
  int bitIndex = value % 8;
  byte[byteIndex] = byte[byteIndex] | 1 << (7 - bitIndex)
}
```

### isHas(int value)
```c++
bool isHash(int value){
  int byteIndex = value / 8;
  int bitIndex = value % 8;
  return byte[byteIndex] & 1 << (7 - bitIndex) > 0
}

```

$\color{red}{例子：}$
![BitSet例子](https://cdn.jsdelivr.net/gh/AemonSwift/AemonSwift@latest/AemonSwift.github.io/images/bloom-filter1.png)
比如我们有一个长度=2的byte数组，2个字节一共有16位，可以表示0-15的数字是否存在。比如我们要验证11是否出现过，那么我们先检查第11个位置是否为1，如果为0，说明11没出现过，然后我们把第11位置为1，表示11已经出现过了。

## BitSet的局限性
1. 当样本分布极度不均匀的时候，BitSet会造成很大空间上的浪费。比如你有10个数，分别是1、2、3、4、5、6、7、8、99999999999；那么你不得不用99999999999个bit位去实现你的BitSet,而这个BitSet的中间绝大多数位置都是0，并且永远不会用到，这显然是极度不划算的.
2. 当元素不是整型的时候，BitSet就不适用了。若你拿到的是一堆url，然后如果你想用BitSet做去重的话，先得把url转换成int型，在转换的过程中难免某些url会计算出相同的int值，于是BitSet的准确性就会降低。
那针对这两种情况有没有解决办法呢？
第一种分布不均匀的情况可以通过hash函数，将元素都映射到一个区间范围内，减少大段区间闲置造成的浪费，这很简单，取模就好了，难的是取模之后的值保证不相同，即不发生hash冲突。
第二种情况，把字符串映射成整数是必要的，那么唯一要做的就是保证我们的hash函数尽可能的减少hash冲突，一次不行我就多hash几次，hash还是容易碰撞，那我就扩大数组的范围，使hash值尽可能的均匀分布，减少hash冲突的概率。
基于这种思想，BloomFilter诞生了。

# 布隆过滤器
本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在”。
相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。

## 核心思想
1. 多个hash，增大随机性，减少hash碰撞的概率
2. 扩大数组范围，使hash值均匀分布，进一步减少hash碰撞的概率。

## 底层数据结构
布隆过滤器是一个 bit 向量或者说 bit 数组。
例如：你有10个Url，你完全可以创建一长度是100bit的数组，然后对url分别用5个不同的hash函数进行hash，得到5个hash后的值，这5个值尽可能的保证均匀分布在100个bit的范围内。然后把5个hash值对应的bit位都置为1，判断一个url是否已经存在时，一次看5个bit位是否为1就可以了，如果有任何一个不为1，那么说明这个url不存在。$\color{red}{这里需要注意的是，如果对应的bit位值都为1，那么也不能肯定这个url一定存在，这个是BloomFilter的特点之一。}$
![bloomFilter例子](https://cdn.jsdelivr.net/gh/AemonSwift/AemonSwift@latest/AemonSwift.github.io/images/bloomFilter2.png)

## BloomFilter的实践
1. 黑名单。比如邮件黑名单过滤器，判断邮件地址是否在黑名单中
2. 排序(仅限于BitSet)。仔细想想，其实BitSet在set(int value)的时候，“顺便”把value也给排序了。
3. 网络爬虫。判断某个URL是否已经被爬取过
4. K-V系统快速判断某个key是否存在。典型的例子有Hbase，Hbase的每个Region中都包含一个BloomFilter，用于在查询时快速判断某个key在该region中是否存在，如果不存在，直接返回，节省掉后续的查询。
5. 利用布隆过滤器减少磁盘 IO 或者网络请求，因为一旦一个值必定不存在的话，我们可以不用进行后续昂贵的查询请求。

既然你使用布隆过滤器来加速查找和判断是否存在，那么性能很低的哈希函数不是个好选择，推荐 MurmurHash、Fnv 这些。

### 大Value拆分
Redis 因其支持 setbit 和 getbit 操作，且纯内存性能高等特点，因此天然就可以作为布隆过滤器来使用。但是布隆过滤器的不当使用极易产生大 Value，增加 Redis 阻塞风险，因此生成环境中建议对体积庞大的布隆过滤器进行拆分。
拆分的形式方法多种多样，但是本质是不要将 Hash(Key) 之后的请求分散在多个节点的多个小 bitmap 上，而是应该拆分成多个小 bitmap 之后，对一个 Key 的所有哈希函数都落在这一个小 bitmap 上。

## BloomFilter的准确性——hash函数个数以及bit向量长度的选择问题
从直观上看，过小的布隆过滤器很快所有的 bit 位均为 1，那么查询任何值都会返回“可能存在”，起不到过滤的目的了。布隆过滤器的长度会直接影响误报率，布隆过滤器越长其误报率越小。
另外，哈希函数的个数也需要权衡，个数越多则布隆过滤器 bit 位置位 1 的速度越快，且布隆过滤器的效率越低；但是如果太少的话，那我们的误报率会变高。

## 分析hash函数个数以隆过滤器长度的选择指导
假设：
- k为hash函数个数
- m为布隆过滤器长度
- n插入元素的个数
- p为误报率

$$m=-\frac{nlnp}{(ln2)^2}$$
$$k=\frac{m}{n}ln2$$
假设哈希函数以相等的概率选择每个数组位置。如果m是数组长度，则哈希函数未将某个位置置为1的概率为：$1-\frac{1}{m}$。
假设k是哈希函数的数量，并且每个散列函数之间没有显着相关性，则该位置未被任何哈希函数设置为1的概率为：$(1-\frac{1}{m})^k$。
如果我们插入了n个元素，此位置仍然为0的概率为：$(1-\frac{1}{m})^{kn}$，故为1的概率为：$1-(1-\frac{1}{m})^{kn}$。
k个哈希函数都将此位置置为1的概率为：$p=(1-(1-\frac{1}{m})^{kn})^k$。
p也就是我们的误差率，我们需要最小化p值。
$$p=(1-(1-\frac{1}{m})^{kn})^k\approx (1-e^{\frac{-kn}{m}})^k $$
我们先给定m,n的值，求导后得出：
$$k=\frac{m}{n}ln2$$
再将求出的k值带入p的表达式中，得：
$$p=(1-e^{\frac{m}{n}ln2\frac{n}{m}})^{\frac{m}{n}ln2}$$
进一步有：
$$lnp=-\frac{m}{n}(ln2)^2$$
从而得到：
$$m=-\frac{nlnp}{(ln2)^2}$$

# 参考文献
[布隆过滤器](https://en.wikipedia.org/wiki/Bloom_filter)
[详解布隆过滤器的原理、使用场景和注意事](https://www.jianshu.com/p/2104d11ee0a2)
[那些惊艳的算法们（一）——布隆过滤器](http://blog.lanjingdejia.com/articles/2018/07/13/1531479344453.html)
[bloom filter与Cuckoo Filter](https://blog.csdn.net/chdhust/article/details/48576961)
[布谷鸟过滤器](https://blog.csdn.net/qq_17305249/article/details/94996252)