---
title: docker基础知识
date: 2019-11-13 08:56:45
tags:
---

# 容器和虚拟化之间的关系

## 常用虚拟化方式
### 主机级别虚拟化——虚拟化整个完整物理硬件平台
两种类型实现：
1. TYPE-1: 有宿主机，在宿主机上安装宿主操作系统，在宿主操作系统系统上安装虚拟机管理器，在虚拟机管理器安装虚拟机
2. TYPE-2: 直接在硬件平台上安装虚拟机管理器，在虚拟机管理器安装虚拟机（没有宿主操作系统）。


运行内核目的：资源分配和管理
真正在用户空间跑的应用程序才是生产力，而现在的软件都是依赖内核而运行，例如：应用程序所依赖的库。
主机级别虚拟化缺陷：产生较多的开销
需要两级调度和资源分配
1. 虚拟机里面存在内核，存在cpu调度和io的调度
2. 虚拟及内核也是被宿主机或硬件平台上的虚拟机管理器进行调度

有时创建虚拟机目的是为了创建几个富有生产力的进程，故在主机级别虚拟化基础上减少中间层，来提高效率。

## 容器
例如：把虚拟机内核抽调，只保留进程。
虚拟机目的：环境隔离。若一台宿主机运行两个Nginx，他们都要监听80端口，而主机上只有一个80套接字。而虚拟机可以达到目的，而且一个nginx损坏了，不会影响其他Nginx的运行。
把虚拟机内核抽调，只保留进程，需要做的是：两个进程相互隔离，而且是不可达的，碰巧是他们共享硬件资源

隔离是隔离的用户空间，一般有一个用户空间是有特权的（一般是第一个），用它来管理其它用户空间。
隔离空间是用来放进程的，给进程提供运行环境，而且保护进程不受其它进程的干扰。即不管这个进程有任何异常行为，都不会影响此隔离空间之外的进程——程序的应用安全运行（防止其他人攻击）。

一个用户空间主要是实现隔离环境，任何进程运行在用户空间的时候，它就以为自己就是唯一一个运行在用户空间内核之上的进程。一个用户空间能看到的东西。
1. 主机名，主机域名 （UTS）
2. 根文件系统（每个用户空间都要有自己独立的根文件系统）（Mount）
3. IPC（信号量，消息队列，共享内存等）。两个用户空间的进程可以通过IPC进行通信，则隔离无任何意义（例如两个进程通过共享内存通信，则隔离无意义）。每个用户空间的IPC是独立的（即一个用户空间的进程可以通过IPC进行通信），但跨用户空间是不行的。而内核管理是期望任何两个进程可以通过IPC进行通信。
4. 进程树（NIT），PID。每个进程应该从属于某个进程（进程右父进程创建），一个系统运行无非就是两棵树——进程树，文件系统树，让进程认为自己是当前用户空间唯一运行的程序，故需要制造出假象：要么自己是一个NIT，要么自己从属于某个NIT（用户空间运行多个进程）。linux进程管理都是子进程的创建和回收都是由父进程来做的。
5. User用户组，运行的进程应该以某个用户身份来运行。第一个用户空间的用户和第二个用户空间的用户的id号一样，但名字不一样是存在。(每个用户空间每个主机上id为0的root，id为1-999的为系统用户，id>1000的为普通登录用户)，而每个用户空间都需要root，但在一个真正的内核空间只能有一个root。产生问题（一个用户空间的root可以管理别人用户空间的资源）。因此用户空间的root只能伪装出来，这个root用户只是一个普通用户，但针对这个用户空间来讲，可以让这个普通用户的id为0，只是让他在此用户空间为所欲为。
6. 网络。每个用户空间都以为自己是系统的唯一一个用户空间，能够看见自己的专用的ip地址，端口，已经tcp/ip协议栈等。而且两个容器间的用户可以通过网络进行通信。而在内核级专用的ip地址，端口，已经tcp/ip协议栈等都是只有一个。

上述资源在内核设计的时候只是针对单个用户空间；为了适应多个用户空间，在内核级直接对上面的资源虚拟化。每种资源只要在内核能够切分为多个互相隔离的环境，我们把它为名称空间。

例如：UTS可以以名称空间为单位进行隔离。在同个内核之上，创建多个名称空间，在名称空间之上，让uts资源的每个名称空间相互隔离。因此每个名称空间都有自己独立的名称，主机名和域名是内核的作用域，所以一个主机房主机名只有一个。但现在有多个用户空间，就必须要为每个用户空间视作这个系统上唯一的用户空间。因此每个名称空间都应有有自己的主机名而且与其他用户空间的主机名不一样。若都是用内核的主机名和域名；则内核混乱了。古内核在内核级进行隔离，让他们分别各自使用而不影响真正的内核空间的用户名和域名。

linux为了适应容器的实现，linux在内核级通过所谓的名称空间机制对上述资源进行了隔离支持。直接通过系统调用向外输出。
创建进程：clone()，把创建的进程放到名称空间去：setns()等

除了上述问题：主机级别隔离；还存在只能使用多少个cpu，以及使用的内存有多大。（超出了限制会直接虚拟的主机直接挂掉，不影响其他虚拟主机）。而容器虚拟化也需要做到这两点。即内核级还要限制名称空间所有的资源总量。（例如3个名称空间：cpu分配：1：2：1（这样分配很有弹性），例如后面两个不启动，第一个用户空间可以吃掉这个cpu的核数；另外一种分配：一个用户空间最多使用几核。而内存资源也是这样）。内核实现这需求，还需要CGroups（control groups）
CGroups（control groups）：把系统资源分为多个组，把每个组的资源量指派到对应的用户空间，而每个子组也可以被再次划分。
- blkio：块设备io
- cpu： cpu
- cpuacct：cpu资源使用报告
- cpuset： 多处理平台上的cpu集合
- devices： 设备访问
- freezer： 挂起或恢复任务
- memory： 内存用量及报告
- perf_event：对cgroup中的任务进行统一性能测试
- net——cls：cgroup中的任务创建的数据报文的类别标识符

容器的隔离能力比主机级虚拟化弱了很多，由于都是属于同一个内核，只不过在内核里强行设置边界。为了防止一个用户空间进程利用漏洞进入另外一个用户空间里，故利用selinx等各种安全加强机制来加固用户空间的边界。

## LXC——linux container
是一组工具，为了用户快速使用容器。
- lxc-create：创建容器（用户空间），用户空间应该有bin，sbin这样的目录结构，以及基本的应用程序，例如ls等，这种东西怎么创建——可以从宿主机进行copy。若创建的用户空间：根用户空间是centos，新用户空间是Ubuntu，则复制宿主空间的是不行的，因此需要一个机制来自动创建对于用户空间的应用程序，——即模板，是一种脚本，创建用户空间的时候回自动执行此脚本，此脚本指向了名称空间指向的linux发行版的仓库，在仓库中把对应需要的东西下载下来。

使用lxc就要学好lxc工具，以及会写定制脚本，更重是每个用户空间都是安装生成的，后来运行过程中生成了很多文件（数据），若此宿主机出现故障的时候，如何将此数据迁移到其他宿主机上？以及批量创建容器也不容易。于是后面出现了docker。

docker是一种容器易用的前端工具，用于简化使用容器。容器是linux内核中的技术，docker只是简化容器使用的工具。docker是在lxc上进行封装发行版。
 docker利用lxc做容器管理引擎，创建用户空间时不再是利用模板去现场安装。而是事先利用一种镜像技术（尝试把os在用户空间用到的所有组件事先准备编排好，打包成一个文件），这些镜像文件放在了互联网的一个集中统一仓库里面，把大家都会用到的镜像都放在仓库里面。为了使得容器使用更加易于管理，docker采用了在一个容器内只运行一个进程（这样可以最小化安装系统工具）。
 这里存在一个坏处：一个系统上的运行进程出现了故障，会使用一组跟踪工具来观察进程运行情况。而现在每个进程应用在自己的用户空间中，这些工具需要在此用户空间携带上（每个用户空间自带调试工具）。调试工具是用到时再启动。当主进程终止时，这个用户空间也没存在意义了。因此，先做调试进程有可能没有工具，以及要突破容器的边界（以前没有边界）。
 docker为开发做到了一次编辑到处运行，以及部署简单。开发以前是为了开发每种平台的软件。现在只是编辑完，打包成镜像。发布只需运行镜像即可。

发布操作可以靠编排工具来实现。
docker还可以批量创建创建容器：每个物理机只需下载一个docker即可，docker运行容器：与它的镜像构建有关。docker的镜像构建机制：分层构建，联合挂载。
分层构建：底层做一个纯净的centos镜像，在此镜像之上装一个nginx。把两个叠放在一起就是一个nginx镜像。使得镜像分发没有那么庞大了，例如运行三个容器，他们可以共同使用底层的镜像（centos镜像），上层就对应特定的服务，nginx，Tomcat等。能这样做的原因：每个镜像只是只读的。
若第一个容器更改了文件，将会影响其他容器。故联合挂载栈的最顶层额外附加新层，这个层是每个容器专有的。若删除文件，只需标记不可见；若改：则写时复制，把底层的东西copy上来，后面只看上面的东西。但存在问题：容器迁移存在问题：由于存在专用层（维持更改），因此真正使用容器时，不会在容器本地保持有效数据。需要在专有层挂载一个外部持久的共享存储。后面重新启动的时候，运行镜像，挂载此共享存储，达到正常运行。

启动的容器调度到集群某个dockerhost主机上面，以及启动有依赖关系的容器序列，移除有依赖的容器序列——这个工具叫容器编排工具。例如：kubernetes等。

现在docker采用另外的引擎：libcontainer，替换了lxc。由于docker要发展，故需要标准化因此从libcontainer发展成runC（OCF——开放容器标准）。
生成镜像要遵循OCI标准

## docker架构
docker daemon，docker client，docker registries三部分组成。
docker是一种C/S架构，遵循restful风格。
运行docker daemon进程表示，把此主机作为服务器，可以监听在某个套接字之上，为了安全，它只提供unix文件的套接字。（mysql有两种接入方法：tcp/ip标准的ip协议接入；使用socket文件接入）
docker host是真正运行容器的主机，关系两个组成：容器，镜像。镜像来自于registry（镜像仓库，用到那个下载那个到本地）。镜像是分层构建的，可以共享很多基础组件供多个镜像使用（由于镜像只可读）。启动容器时是基于镜像而启动的，是为了一个容器创建一个专用的可写仓库。

docker registries：docker repository只放一个应用程序，是为了此应用程序不断升级产生的多个版本。而每个仓库名就是应用程序名，例如nginx。但为了区分仓库中的镜像，故需要标签来区分。因此：只有仓库名+标签才能唯一确定一个镜像
镜像和容器的关系就是程序和进程之间的关系。镜像是静态的，容器是动态的。
任何restful的资源都是可以进行增删改查，docker中的例如：镜像，容器，网络，卷，插件等。