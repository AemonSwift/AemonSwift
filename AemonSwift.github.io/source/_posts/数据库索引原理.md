---
title: 数据库索引原理
date: 2019-11-01 11:03:44
tags: 
- 数据库
- 索引
categories:
- 数据库
- 索引
---
# 数据库为什么要选择B+树作为索引
1. 数据库为什么需要索引

数据库存储了1000W条数据，要从中找到name=”shenjian”的记录，一条条查，要查到什么时候去？于是，$\color{red}{要有索引，用于提升数据库的查找速度。}$

2. 哈希(hash)比树(tree)更快，索引结构为什么要设计成树型？
加速查找速度的数据结构，常见的有两类：
- 哈希，例如HashMap，查询/插入/修改/删除的平均时间复杂度都是O(1)；
- 树，例如平衡二叉搜索树，查询/插入/修改/删除的平均时间复杂度都是O(lg(n))；
可以看到，不管是读请求，还是写请求，哈希类型的索引，都要比树型的索引更快一些，那为什么，索引结构要设计成树型呢？
索引设计成树形，和SQL的需求相关。select * from t where name=”shenjian”，确实是哈希索引更快，因为每次都只查询一条记录。但是对于排序查询的SQL需求：分组（group by），排序（order by），比较（>,<）等，哈希型的索引，时间复杂度会退化为O(n)，而树型的“有序”特性，依然能够保持O(log(n)) 的高效率。

## 常见的树
### 二叉树
当数据量大的时候，树的高度会比较高，数据量大的时候，查询会比较慢；每个节点只存储一个记录，可能导致一次查询有很多次磁盘IO；

###  B树
特点：
a. 不再是二叉搜索，而是m叉搜索；
b. 叶子节点，非叶子节点，都存储数据；
c. 中序遍历，可以获得所有节点；
B树被作为实现索引的数据结构被创造出来，是因为它能够完美的利用“局部性原理”。(所谓局部性原理：1. 内存读写块，磁盘读写慢，而且慢很多；2. 磁盘预读：磁盘读写并不是按需读取，而是按页预读，一次会读一页的数据，每次加载更多的数据，如果未来要读取的数据就在这一页中，可以避免未来的磁盘IO，提高效率；3. 局部性原理：软件设计要尽量遵循“数据读取集中”与“使用到一个数据，大概率会使用其附近的数据”，这样磁盘预读能充分提高磁盘IO；)
B树为何适合做索引：1. 由于是m分叉的，高度能够大大降低；2. 每个节点可以存储j个记录，如果将节点大小设置为页大小，例如4K，能够充分的利用预读的特性，极大减少磁盘IO；

### B+树 
仍是m叉搜索树，在B树的基础上，做了一些改进：
1. 非叶子节点不再存储数据，数据只存储在同一层的叶子节点上；（B+树中根到每一个节点的路径长度一样，而B树不是这样。）
2. 叶子之间，增加了链表，获取所有节点，不再需要中序遍历；
与B树相比，优势：
1. 范围查找，定位min与max之后，中间叶子节点，就是结果集，不用中序回溯；
2. 叶子节点存储实际记录行，记录行相对比较紧密的存储，适合大数据量磁盘存储；非叶子节点存储记录的PK，用于查询加速，适合内存存储；
3. 非叶子节点，不存储实际记录，而只存储记录的KEY的话，那么在相同内存的情况下，B+树能够存储更多索引；
## 选择B+树的原因
1. 数据库索引用于加速查询
2. 虽然哈希索引是O(1)，树索引是O(log(n))，但SQL有很多“有序”需求，故数据库使用树型索引
3. 数据预读的思路是：磁盘读写并不是按需读取，而是按页预读，一次会读一页的数据，每次加载更多的数据，以便未来减少磁盘IO
4. 局部性原理：软件设计要尽量遵循“数据读取集中”与“使用到一个数据，大概率会使用其附近的数据”，这样磁盘预读能充分提高磁盘IO
5. 很低的树高度，能够存储大量数据；
6. 索引本身占用的内存很小；
7. 能够很好的支持单点查询，范围查询，有序性查询；
9. InnoDB不支持哈希索引

# 聚集索引与非聚集索引
- 非聚集索引：索引与行记录是分开存储的
- 聚集索引：主键索引与行记录是存储在一起的

## MyISAM索引
其主键索引与普通索引没有本质差异：（MyISAM的表可以没有主键。）
1. 有连续聚集的区域单独存储行记录
2. 主键索引的叶子节点，存储主键和对应行记录的指针
3. 普通索引的叶子结点，存储索引列和对应行记录的指针

## InnoDB索引
InnoDB必须要有聚集索引，行记录按照聚集索引物理上排序。必须要有聚集索引，并不代表一定要有主键。
InnoDB的主键索引与行记录是存储在一起的，
1. 没有单独区域存储行记录
2. 主键索引的叶子节点，存储主键和对应行记录（而不是指针）
因此，InnoDB的PK查询是非常快的。
因为这个特性，InnoDB必须有聚集索引：
1. 如果表定义了主键，则PK就是聚集索引；
2. 如果没有主键被定义，那么该表的第一个唯一非空索引被作为聚集索引。
3. 如果没有主键也没有合适的唯一索引，那么innodb内部会生成一个隐藏的主键作为聚集索引，这个隐藏的主键是一个6个字节的列，该列的值会随着数据的插入自增。
聚集索引，也只能够有一个，因为数据行在物理磁盘上只能有一份聚集存储。
InnoDB的普通索引可以有多个，它与聚集索引是不同的：
1. 普通索引的叶子节点，存储索引列和主键（也不是指针）
对于InnoDB表，这里的启示是：
1. 不建议使用较长的列做主键，例如char(64)，因为所有的普通索引都会存储主键，会导致普通索引过于庞大；
2. 建议使用趋势递增的key做主键，由于数据行与索引一体，这样不至于插入记录时，有大量索引分裂，行记录移动；

## 主键的选择
1. 不能为空的列
2. 不能重复的列
3. 很少改变的列：行是按照聚集索引物理排序的，如果主键频繁改变，物理顺序会改变，性能会急剧降低。
4. 经常被检索的列：被检索的列上要建立索引，如果该索引是聚集索引，能够避免回表，性能提升几乎一倍。
5. 不是太长的列：普通索引叶子节点会存储主键值，如果主键值太长，会增加普通索引的大小。

### 主键和聚集索引的区别
1. InnoDB一定会存在聚集索引的，故建立表的时候可以没有主键，其聚集索引如何选择，见上述描述。
2. 建立表时若不声明主键非空，InnoDB会自动添加非空(not null)且唯一(unique)的限制。
```sql 
(1) create table user(
         id int,
         name varchar(10),
         primary key(id)
)engine=innodb;
(2) insert into user(name) values('shenjian');
(3) insert into user(name) values('shenjian');

#执行第三行的时候会报错，产生主键冲突
# 执行show create table命令查看表时，发现表结构为：
create table user(
         id int(11) NOT NULL DEFAULT '0',
         name varchar(10) DEFAULT NULL,
         primary key(id)
)engine=innodb;
```
3. 建立表的时候，可以选择多个字段作为主键——只要满足聚集索引的要求即可。
4. 建立表的时候可以单独使用自增主键，插入记录的时候也可以插入主键id（但要保证主键不能冲突）
5. 建立表的时候使用联合自增主键时注意设置主键的顺序——必须保证自增主键在第一列。
```SQL 
create table user(
         id int(11) NOT NULL DEFAULT '0' auto_increment,
         name varchar(10) DEFAULT NULL,
         primary key(name,id), #使用这个主键，建表将会报错
         primary key(id,name), # 使用此主键，建表正确（必须保证自增主键在第一列）
)engine=innodb;
```
例如：`select * from t where name=‘lisi’;`会先通过name辅助索引定位到B+树的叶子节点得到id=5，再通过聚集索引定位到行记录。——扫描列两次索引树。
如何解决扫描两次索引树得到结果？——索引覆盖

### 索引覆盖
$\color{red}{索引覆盖：}$只需要在一棵索引树上就能获取SQL所需的所有列数据，无需回表，速度更快。
使用explain查询sql命中的索引时，即explain的输出结果Extra字段为Using index时，能够触发索引覆盖。
解决方法：建立两列以上的索引，查询复合索引里的列的数据不需要进行回表二次查询，如index(col1, col2)，执行下面的语句：(主键id可以例外：因为叶子节点存储了索引列和主键id)
`select col1, col2 from t1 where col1 = '213';`
#### 哪些场景可以利用索引覆盖来优化SQL？
1. 全表count查询优化  `select count(name) from user`,只要name可以进行索引，就会输出结果Extra字段为Using index（索引覆盖）
2. 列查询回表优化——将单列索引(name)升级为联合索引(name, sex)，即可避免回表。`select id,name,sex ... where name='shenjian';`
3. 分页查询。`select id,name,sex ... order by name limit 500,100;`将单列索引(name)升级为联合索引(name, sex)，也可以避免回表。

# 参考文献
[1分钟了解MyISAM与InnoDB的索引差异](https://mp.weixin.qq.com/s/FUXPXKfKyjxAvMUFHZm9UQ)
[数据库索引，到底是什么做的？](https://mp.weixin.qq.com/s/YMbRJwyjutGMD1KpI_fS0A)
[Mysql的聚集索引与辅助索引](https://www.jianshu.com/p/3cd3cec2e28c)
[如何避免回表查询？什么是索引覆盖？](https://mp.weixin.qq.com/s/y0pjtNUZhOW2ZBOy4m-xsA)