---
title: 字节对齐和字节序列问题
date: 2019-11-13 08:56:45
tags:
---

# 什么是字节对齐
计算机中内存大小的基本单位是字节（byte），理论上来讲，可以从任意地址访问某种基本数据类型，但是实际上，计算机并非逐字节大小读写内存，而是以2,4,或8的 倍数的字节块来读写内存，如此一来就会对基本数据类型的合法地址作出一些限制，即它的地址必须是2，4或8的倍数。那么就要求各种数据类型按照一定的规则在空间上排列，这就是对齐。
## 字节对齐准则
1. 结构体变量的首地址能够被其对齐字节数大小所整除。
2. 结构体每个成员相对结构体首地址的偏移都是成员大小的整数倍，如不满足，对前一个成员填充字节以满足。
3. 结构体的总大小为结构体对齐字节数大小的整数倍，如不满足，最后填充字节以满足。
可以采用sizeof关键字来进行测试
```c++
struct test
{
    int a;
    char b;
    int c;
    short d;
};
sizeof(struct test); //大小为16
```
# 为什么需要字节对齐

无论数据是否对齐，大多数计算机还是能够正确工作，而且从前面可以看到，结构体test本来只需要11字节的空间，最后却占用了16字节，很明显浪费了空间，那么为什么还要进行字节对齐呢？最重要的考虑是提高内存系统性能
前面我们也说到，计算机每次读写一个字节块，例如，假设计算机总是从内存中取8个字节，如果一个double数据的地址对齐成8的倍数，那么一个内存操作就可以读或者写，但是如果这个double数据的地址没有对齐，数据就可能被放在两个8字节块中，那么我们可能需要执行两次内存访问，才能读写完成。显然在这样的情况下，是低效的。所以需要字节对齐来提高内存系统性能。
在有些处理器中，如果需要未对齐的数据，可能不能够正确工作甚至crash，这里我们不多讨论。
## 实际编程考虑——减少空间的存储（需要程序人员关注）
```c++
struct test
{
    int a;
    char b;
    short d;
    int c;
};

sizeof(struct test); //大小为12
```
如果我们在设计结构的时候，合理调整成员的位置，可以大大节省存储空间。

## 跨平台通信（不同平台对齐方式不同）
由于不同平台对齐方式可能不同，如此一来，同样的结构在不同的平台其大小可能不同，在无意识的情况下，互相发送的数据可能出现错乱，甚至引发严重的问题。因此，为了不同处理器之间能够正确的处理消息，我们有两种可选的处理方法。
1. 1字节对齐
2. 自己对结构进行字节填充

### 1字节对齐
我们可以使用伪指令#pragma pack(n)（n为字节对齐数）来使得结构间一字节对齐。
同样是前面的程序，如果在结构体test的前面加上伪指令，即如下:
```c++
#pragma pack(1) /*1字节对齐*/
struct test
{
    int a;
    char b;
    int c;
    short d;
};
#pragma pack()/*还原默认对齐*/
```
在这样的声明下，任何平台结构体test的大小都为11字节，这样做能够保证跨平台的结构大小一致，同时还节省了空间，但不幸的是，降低了效率。
当然了对于单个结构体，gcc还有如下的方法，使其1字节对齐
```c++
struct test
{
    int a;
    char b;
    int c;
    short d;
}__attribute__ ((packed));
```
1. __attribute__((aligned (n)))，让所作用的结构成员对齐在n字节自然边界上。如果结构中有成员的长度大于n，则按照最大成员的长度来对齐。
2. __attribute__ ((packed))，取消结构在编译过程中的优化对齐，也可以认为是1字节对齐。
### 人为填充
```c++
struct test
{
    int a;
    char b;
    char reserve[3];
    int c;
    short d;
    char reserve1[2];
};
```
访问效率高，但并不节省空间，同时扩展性不是很好，例如，当字节对齐有变化时，需要填充的字节数可能就会发生变化。
# 字节对齐总结
虽然我们不需要具体关心字节对齐的细节，但是如果不关注字节对齐的问题，可能会在编程中遇到难以理解或解决的问题。因此针对字节对齐，总结了以下处理建议：
1. 结构体成员合理安排位置，以节省空间
2. 跨平台数据结构可考虑1字节对齐，节省空间但影响访问效率
3. 跨平台数据结构人为进行字节填充，提高访问效率但不节省空间
4. 本地数据采用默认对齐，以提高访问效率

# 字节序列
字节序关系到我们的网络数据能否被正确地解析或使用。那么什么是字节序？又怎么处理字节序的问题呢？
字节序指的是多字节的数据各字节的存储顺序。在几乎所有计算机中，多字节数据被存储为连续的字节序列。例如，一个4字节的int类型变量a，其存储的起始地址为0x804900，那么a的四个字节将被分别存在0x804900，0x804901，0x804902，0x804903的位置。但是问题来了，a的最低有效位可以存储在最前面，也可以存储在高最后面，就有两种不同的存储顺序。这就引出了大端序和小端序。

## 大端序和小端序
如果最低有效位在最高有效位的前面，则该存储规则为小端序；反之，如果最低有效位在最高有效的后面，则该存储规则为大端序。不同的处理器体系，采用的字节序可能是不同的。例如，x86采用小端序，而PowerPc 970等采用大端序。那么如此一来，不同机器之间的数据传输是不是会出问题呢？

## 本地序和网络序
本地序（也称主机序）即指前面处理器本身所采用的字节序，因此有的大端序，有的小端序。而网络序，是指网络传输采用的字节序。所幸，网络序是标准化的，即一般统一采用大端序。因此，发送网络数据之前需要将数据转换为网络序，从而避免了前面所担心的问题。而C语言也针对整型数据提供了一组接口，htonl、htons用于本地序转网络序，以及ntohl、ntohs用于网络序转本地序。

## 为什么不统一字节序
既然每次都发送网络数据之前都要转换，为什么不统一字节序呢？实际上，大小端各有优劣：
1. 计算都是从低位开始的，因此计算机内部处理采用小端序，效率较高。
2. 而大端序存储的时候，由于符号位在高位，因此对于数据正负或大小的判断也就方便许多。另外，大端序也更符合人类的阅读习惯。
再由于各个芯片厂商的坚持，字节序的问题也就一直没有统一。

# 总结
在网络应用中，字节序的问题不可忽略，否则可能出现无法预知的问题（如果两台机器本地序相同，且都不做字节序转换，那么侥幸不会出现什么问题）。通过前面的介绍和分析，我们总结出以下几点：
1. 不同处理器之间采用的字节序可能不同。
2. 有些处理器的字节序是确定的，有些处理器的字节序是可配置的。
3. 网络序一般统一为大端序。
4. 数据从本地传输到网络，需要转换为网络序，接收到的网络数据需要转换为本地序后使用。
5. C提供了一组接口用于整型数据在本地序和网络序之间的转换。
6. 多字节数据对象才需要转字节序，例如int，short等，而char不需要。
7. 由于处理器是按照IEEE标准处理float和double的，因此也不需要转字节序。
8. 由于Java虚拟机的存在，Java不需要考虑大小端的问题。


