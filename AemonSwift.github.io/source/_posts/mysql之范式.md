---
title: mysql之范式
date: 2019-11-04 19:17:19
tags:
- 数据库
- 表设计
categories:
- 数据库
- 表设计
---
# 为什么存在范式
引入范式的目的主要是解决数据冗余问题。
例如：
![订单综述表](https://cdn.jsdelivr.net/gh/AemonSwift/AemonSwift@latest/AemonSwift.github.io/images/mysql范式1.png)
数据库看上去像一个表格，其实不然，比如如下的订单表，一个订单号X2001对应一个用户，但是还对应了两行产品，非常不规范。
要想把这个表规范化，可以使用范式。

# 第一范式——字段是不可再分
即不存在一个字段中存在两个及以上值的情况。
在上述例子中，为了规范话，我们可以进行拆分两个表格。
一个是订单表：一个订单号可以唯一的确定一行
![订单表](https://cdn.jsdelivr.net/gh/AemonSwift/AemonSwift@latest/AemonSwift.github.io/images/mysql范式12png)
一个是细节表：一个订单号+产品编码才可以唯一的确定一行。
![细节表](https://cdn.jsdelivr.net/gh/AemonSwift/AemonSwift@latest/AemonSwift.github.io/images/mysql范式3.png)
所以我们说订单表的主键是 （订单号）， 细节表的主键是（订单号，产品编码）， 这是一个复合主键。

# 第二范式——所有属性都依赖于主键
即把其它不想关的字段都拆分出去。
再看看订单细节表， 产品名称和单价实际上并不依赖于订单号。如果想添加一个新的产品， 你会发现没法放入这张表， 因为没有订单号！
![细节表](https://cdn.jsdelivr.net/gh/AemonSwift/AemonSwift@latest/AemonSwift.github.io/images/mysql范式4.png)
所以还需要进行拆分
![拆分后的表](https://cdn.jsdelivr.net/gh/AemonSwift/AemonSwift@latest/AemonSwift.github.io/images/mysql范式5.png)
拆分以后，表4.1订单细节表的主键还是（订单号，产品编码），但是剩下的属性（数量）肯定是完全依赖于主键的。表4.2产品表也类似，主键是产品编码，剩下的属性都依赖于产品编码

## 不满足第二范式存在如下问题
1. 数据冗余：同个用户可以产生n个订单，用户的名称重复了n-1次
2. 更新异常：若用户更改自己的名称时，数据表关于此用户所在行的名称都要更新，否则导致用户名称不一致性。
3. 插入异常：若出现一个新用户时，用户只来注册。不来买东西，则这个用户是无法插入到数据库中。
4. 删除异常：一批用户已完成产品的买入，这些记录应该从数据库表中删除。但删除时导致用户的信息也删除。

# 第三范式——消除依赖传递(属性不依赖于其它非主属性)
我们再回过头来看一下表格3 订单表，它的主键是订单号，所有的属性都依赖于主键，已经是第二范式。 但是我们发现，订单号能决定用户ID，用户ID能决定用户名称，这就出现了依赖传递：$\color{red}{订单号->用户ID->用户名称}$。
![依赖传递表]](https://cdn.jsdelivr.net/gh/AemonSwift/AemonSwift@latest/AemonSwift.github.io/images/mysql范式6.png)
进行拆分：
![拆分表]](https://cdn.jsdelivr.net/gh/AemonSwift/AemonSwift@latest/AemonSwift.github.io/images/mysql范式7.png)
## 不满足第二范式存在如下问题
1. 数据冗余：
2. 更新异常：
3. 插入异常：
4. 删除异常：

# BC范式——消除非主属性对任一一个候选键依赖
例如：
仓库管理表，且有一个管理员只在一个仓库工作；一个仓库可以存储多种物品
仓库|	管理员	|物品类型	|数目
:-:|:-:|:-:|:-:
1	|刘老师|	物品A|	10
1|	刘老师|	物品B|	15
2|	王老师	|物品B|	20
2	|王老师|	物品C|	10
... ...	|... ...	|... ...	|... ...
表中候选键有：(仓库，物品类型)和(管理员，物品类型)，由于一个管理员只能为一个仓库的管理员，故（仓库，管理员，物品类型）都是关键字段，而数目为非关键字段。
这张表符合1NF元素不可分。符合2NF，因为证书数目由(仓库，物品类型)决定，但是(管理员，物品类型)也能决定。对于3NF，它也是符合的，因为只有一个非主属性，肯定是由码直接决定的啦。$\color{red}{那么BCNF的规范是什么呢？就是不能有主属性的互相推导。就是说，如果存在(仓库->管理员)(管理员->仓库)这种关系，是不符合BCNF的。}$
出现关键字段决定关键字段{(仓库->管理员)(管理员->仓库)}，将会有如下异常：
1. 删除异常：当仓库被清空后，所有"存储物品ID"和"数量"信息被删除的同时，"仓库ID"和"管理员ID"信息也被删除了。
2. 插入异常：当仓库没有存储任何物品时，无法给仓库分配管理员。
3. 更新异常：如果仓库换了管理员，则表中所有行的管理员ID都要修改。

应该把仓库管理关系表分解为二个关系表：
表1
班级|	竞赛学科|	证书数目
:-:|:-:|:-:
1班	|物理	|10
1班	|化学	|15
2班	|生物|	20
2班|	物理|	10
... ...|	... ...|	... ...

表2
班级|	班主任
:-:|:-:
1班|	刘老师
2班	|王老师
... ...|	... ...

# 第四范式——属性之间不允许有非平凡且非函数依赖的多值依赖
即当一个表中的非主属性互相独立时（3NF），这些非主属性不应该有多值。若有多值就违反了第四范式。
有这样一个用户联系方式表TELEPHONE(CUSTOMERID,PHONE,CELL)。CUSTOMERID为用户ID,PHONE为用户的固定电话,CELL为用户的移动电话。
本来，这是一个非常简单的第3范式表。主键为CUSTOMERID，不存在传递依赖。但在某些情况下，这样的表还是不合理的。比如说，用户有两个固定电话，两个移动电话。这时，表的具体表示如下：

CUSTOMERID| PHONE| CELL
:-:|:-:|:-:
1000 |8828-1234 |149088888888
1000 |8838-1234 |149099999999
由于PHONE和CELL是互相独立的，而有些用户又有两个和多个值。这时此表就违反第四范式。
在这种情况下，此表的设计就会带来很多维护上的麻烦。例如，如果用户放弃第一行的固定电话和第二行的移动电话，那么这两行会合并吗？等等
解决问题的方法为，设计一个新表NEW_PHONE(CUSTOMERID,NUMBER,TYPE).这样就可以对每个用户处理不同类型的多个电话号码，而不会违反第四范式。
显然，第四范式的应用范围比较小，因为只有在某些特殊情况下，要考虑将表规范到第四范式。所以在实际应用中，一般不要求表满足第四范式。

# 第五范式——最终范式，消除4NF中的连接依赖
表必须可以分解为较小的表，除非那些表在逻辑上拥有与原始表相同的主键。
第五范式是在第四范式的基础上做的进一步规范化。第四范式处理的是相互独立的多值情况，而第五范式则处理相互依赖的多值情况。
有一个销售信息表SALES（SALEPERSON，VENDOR，PRODUCT）。SALEPERSON代表销售人员，VENDOR代表供货商，PRODUCT则代表产品。

在某些情况下，这个表中会产生一些冗余。可以将表分解为PERSON_VENDOR表（SALEPERSON，VENDOR）；PERSON_PRODUCT表（SALEPERSON，PRODUCT）；VENDOR­_PRODICT表（VENDOR，PRODUCT）
# 总结
6种范式的关系为：$1NF\supset 2NF \supset 3NF \supset BCNF \supset 4NF \supset 5NF$
一般表达设计只考虑到BCNF即可，为了满足范式要求，需要把一张大表拆分开，到时候查询岂不是非常麻烦？是的，需要将这些表Join起来，如果数据量大的时候，连接非常耗时。$\color{red}{但有时为了加快数据的查询速度（减少多次查询）我们需要违反范式，做点数据冗余。}$

# 参考文献
[数据库6大范式](https://www.cnblogs.com/Diyo/p/11414424.html)