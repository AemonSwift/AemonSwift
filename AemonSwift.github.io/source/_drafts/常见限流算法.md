---
title: 常见限流算法
tags:
- 算法
- 系统
categories:
- 系统
- 限流
toc: true
---
# 为什么需要限流算法
在高并发系统中，保护系统三大利器：缓存，降级，限流，即主要降低数据库的访问。当请求量超过系统负载的时候，为了保证系统正常运行，当请求达到一定的并发数或速率，就需要进行等待、排队、降级、拒绝服务等，从而保证了有效系统正常运行。
按照服务调用方分为如下几种类型
1. 与用户打交道服务
这类服务导致系统负载过高原因：
- 用户增长过快（好事）
- 某个热点事件（微博热搜）
- 竞争对象爬虫
- 恶意刷单
这类系统都是无法预知的，即弹性扩容根本不可能实现。
2. 对内的RPC服务
一个服务A的接口可能被B，C，D，E多个服务进行调用，在B服务发生突发流量时，直接把A服务给调用挂了，导致A服务对C，D，E也无法提供服务。解决方案如下：a.每个调用方采用线程池进行资源隔离；b.使用限流手段对每个调用方进行限流。
# 常见的限流算法
计数器，令牌桶，漏桶，窗口等
## 计数器限流
主要用来限制总并发数，比如数据库连接池大小、线程池大小、程序访问并发数等都是使用计数器算法。
### 计数器限流示例1
```go
var count int32
const total = 10
func exec() {
	tmp := atomic.LoadInt32(&count)
	if atomic.CompareAndSwapInt32(&count, 10, tmp+1) {
		//处理业务程序
	} else {
		fmt.Println("请求用户过多，请稍后重试")
		time.Sleep(1 * time.Second)
	}
}
```
使用count进行统计当前正在并发执行的次数，如果超过域值就简单粗暴的直接响应给用户，说明系统繁忙，请稍后再试或其它跟业务相关的信息。
$\color{red}{弊端：}$使用count简单粗暴超过域值就拒绝请求，可能只是瞬时的请求量高，也会拒绝请求。
### 计数器限流示例2——时间切片
上述方法简单粗暴，一般我们会限制一秒钟的能够通过的请求数，比如限流qps为100，算法的实现思路就是从第一个请求进来开始计时，在接下去的1s内，每来一个请求，就把计数加1，如果累加的数字达到了100，那么后续的请求就会被全部拒绝。等到1s结束后，把计数恢复成0，重新开始计数。
```go
var count int32
const total = 100
var ticker = time.NewTicker(1 * time.Second)
func exec() {
	select {
	case <-ticker.C:
		atomic.SwapInt32(&count, 0)
	}
	tmp := atomic.LoadInt32(&count)
	if atomic.CompareAndSwapInt32(&count, total, tmp+1) {
		if tmp>total{ //为了并发考虑加入：一个协程执行玩tmp得到值的时候，另外一个立马要执行count赋值为0
			fmt.Println("请求用户过多，请稍后重试")
			time.Sleep(1 * time.Second)
			return 
		}
		//处理业务程序
	} else {
		fmt.Println("请求用户过多，请稍后重试")
		time.Sleep(1 * time.Second)
	}
}
```
$\color{red}{弊端：}$如果我在单位时间1s内的前10ms，已经通过了100个请求，那后面的990ms，只能请求拒绝，我们把这种现象称为“突刺现象”.
### 计数器限流示例3——采用队列的形式
形式类似信号量Semaphore。
```go
func main() {
    var wg sync.WaitGroup
    sem := make(chan struct{}, 2) // 最多允许2个并发同时执行
    taskNum := 10
    for i := 0; i < taskNum; i++ {
        wg.Add(1)

        go func(id int) {
            defer wg.Done()

            sem <- struct{}{}        // 获取信号
            defer func() { <-sem }() // 释放信号

            // do something for task
            time.Sleep(time.Second * 2)
            fmt.Println(id, time.Now())
        }(i)
    }
    wg.Wait()
}
```
如果是瞬时的高并发，可以使请求在阻塞队列中排队，而不是马上拒绝请求，从而达到一个流量削峰的目的。但无法应对短时间的突发流量。
## 漏桶限流
为了消除"突刺现象"，可以采用漏桶算法实现限流，漏桶算法这个名字就很形象，算法内部有一个容器，类似生活用到的漏斗，当请求进来时，相当于水倒入漏斗，然后从下端小口慢慢匀速的流出。不管上面流量多大，下面流出的速度始终保持不变。
不管服务调用方多么不稳定，通过漏桶算法进行限流，每10毫秒处理一次请求。因为处理的速度是固定的，请求进来的速度是未知的，可能突然进来很多请求，没来得及处理的请求就先放在桶里，既然是个桶，肯定是有容量上限，如果桶满了，那么新进来的请求就丢弃。

弊端：无法应对短时间的突发流量。

## 令牌桶限流
令牌桶算法（Token Bucket）：是网络流量整形（Traffic Shaping）和速率限制（Rate Limiting）中最常使用的一种算法。典型情况下，令牌桶算法用来控制发送到网络上的数据的数目，并允许突发数据的发送。

## 窗口限流

# 参考文献
[go channel实现简单信号量](https://blog.csdn.net/qq_15437667/article/details/70769084)
[go语言生产者消费者信号量实现](https://blog.csdn.net/qq_30505673/article/details/82156834)
[高并发系统限流-漏桶算法和令牌桶算法](https://blog.csdn.net/weixin_42296449/article/details/90318706)
[谈谈服务限流算法的几种实现](https://blog.csdn.net/linhui258/article/details/81155622)
[常用的限流算法](https://www.cnblogs.com/senlinyang/p/7840304.html)
[高并发系统限流中的漏桶算法和令牌桶算法，通过流量整形和速率限制提升稳定性](https://blog.csdn.net/scorpio3k/article/details/53103239)
[高并发系统限流中的算法](https://blog.csdn.net/u012526691/article/details/80333907)
[限流算法比较与实现](https://www.jianshu.com/p/ee2c8843f7a9)
[接口限流算法（关于临界点处理）](https://blog.csdn.net/ljj821061514/article/details/52512943)
[限流算法的理解和应用场景和实现[临界点处理](https://blog.csdn.net/u010963948/article/details/79424413)
