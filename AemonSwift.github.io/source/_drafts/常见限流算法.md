---
title: 常见限流算法
tags:
- 算法
- 系统
categories:
- 系统
- 限流
toc: true
---
# 为什么需要限流算法
在高并发系统中，保护系统三大利器：缓存，降级，限流，即主要降低数据库的访问。当请求量超过系统负载的时候，为了保证系统正常运行，当请求达到一定的并发数或速率，就需要进行等待、排队、降级、拒绝服务等，从而保证了有效系统正常运行。
按照服务调用方分为如下几种类型
1. 与用户打交道服务
这类服务导致系统负载过高原因：
- 用户增长过快（好事）
- 某个热点事件（微博热搜）
- 竞争对象爬虫
- 恶意刷单
这类系统都是无法预知的，即弹性扩容根本不可能实现。
2. 对内的RPC服务
一个服务A的接口可能被B，C，D，E多个服务进行调用，在B服务发生突发流量时，直接把A服务给调用挂了，导致A服务对C，D，E也无法提供服务。解决方案如下：a.每个调用方采用线程池进行资源隔离；b.使用限流手段对每个调用方进行限流。
# 常见的限流算法
计数器，令牌桶，漏桶，窗口等
## 计数器限流
主要用来限制总并发数，比如数据库连接池大小、线程池大小、程序访问并发数等都是使用计数器算法。
### 计数器限流示例1
```go
var count int32
const total = 10
func exec() {
	tmp := atomic.LoadInt32(&count)
	if atomic.CompareAndSwapInt32(&count, 10, tmp+1) {
		//处理业务程序
	} else {
		fmt.Println("请求用户过多，请稍后重试")
		time.Sleep(1 * time.Second)
	}
}
```
使用count进行统计当前正在并发执行的次数，如果超过域值就简单粗暴的直接响应给用户，说明系统繁忙，请稍后再试或其它跟业务相关的信息。
$\color{red}{弊端：}$使用count简单粗暴超过域值就拒绝请求，可能只是瞬时的请求量高，也会拒绝请求。
### 计数器限流示例2——时间切片
上述方法简单粗暴，一般我们会限制一秒钟的能够通过的请求数，比如限流qps为100，算法的实现思路就是从第一个请求进来开始计时，在接下去的1s内，每来一个请求，就把计数加1，如果累加的数字达到了100，那么后续的请求就会被全部拒绝。等到1s结束后，把计数恢复成0，重新开始计数。
```go
var count int32
const total = 100
var ticker = time.NewTicker(1 * time.Second)
func exec() {
	select {
	case <-ticker.C:
		atomic.SwapInt32(&count, 0)
	}
	tmp := atomic.LoadInt32(&count)
	if atomic.CompareAndSwapInt32(&count, 10, tmp+1) {
		//处理业务程序
	} else {
		fmt.Println("请求用户过多，请稍后重试")
		time.Sleep(1 * time.Second)
	}
}
```
$\color{red}{弊端：}$如果我在单位时间1s内的前10ms，已经通过了100个请求，那后面的990ms，只能请求拒绝，我们把这种现象称为“突刺现象”.
### 计数器限流示例3——采用队列的形式
形式类似信号量Semaphore。
```go
func main() {
    var wg sync.WaitGroup
    sem := make(chan struct{}, 2) // 最多允许2个并发同时执行
    taskNum := 10
    for i := 0; i < taskNum; i++ {
        wg.Add(1)

        go func(id int) {
            defer wg.Done()

            sem <- struct{}{}        // 获取信号
            defer func() { <-sem }() // 释放信号

            // do something for task
            time.Sleep(time.Second * 2)
            fmt.Println(id, time.Now())
        }(i)
    }
    wg.Wait()
}
```
## 令牌桶限流
## 漏桶限流
## 窗口限流

# 参考文献
[go channel实现简单信号量](https://blog.csdn.net/qq_15437667/article/details/70769084)
[go语言生产者消费者信号量实现](https://blog.csdn.net/qq_30505673/article/details/82156834)
[高并发系统限流-漏桶算法和令牌桶算法](https://blog.csdn.net/weixin_42296449/article/details/90318706)
[谈谈服务限流算法的几种实现](https://blog.csdn.net/linhui258/article/details/81155622)
[常用的限流算法](https://www.cnblogs.com/senlinyang/p/7840304.html)
[高并发系统限流中的漏桶算法和令牌桶算法，通过流量整形和速率限制提升稳定性](https://blog.csdn.net/scorpio3k/article/details/53103239)
[高并发系统限流中的算法](https://blog.csdn.net/u012526691/article/details/80333907)
[限流算法比较与实现](https://www.jianshu.com/p/ee2c8843f7a9)
[接口限流算法（关于临界点处理）](https://blog.csdn.net/ljj821061514/article/details/52512943)
[限流算法的理解和应用场景和实现[临界点处理](https://blog.csdn.net/u010963948/article/details/79424413)
